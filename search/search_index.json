{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About \u00b6 Heads up! This documentation is for v1 of Vale. Check out the v2 docs at https://errata-ai.gitbook.io/vale/ ! Vale is a cross-platform (macOS, Windows, and Linux),command-line linter for prose built with speed and extensibility in mind. Unlike most writing-related software, Vale's primary purpose isn't to provide its own advice; it's designed to enforce an existing style guide through its YAML-based extension system . No matter if you're working with a small in-house standard or a large editorial style guide, Vale will help you maintain consistent and error-free writing. Installation \u00b6 Vale offers multiple options for installation, each of which best suits a particular use case. Remote, collaborative use \u00b6 One of Vale's strengths is its ability to help a company, project, or organization maintain consistency (capitalization styles, word choice, brand terminology, etc.) across multiple writers. The benefits of the following installation methods are that every writer has access to the same Vale configuration without having to install and configure the tools themselves. Using Vale with GitHub \u00b6 If you want to lint the contents of a GitHub repository, the recommended approach is to use Vale's official GitHub Action . Using Vale with a continuous integration (CI) service \u00b6 If you want to use Vale with a CI service such as Travis CI, CircleCI, or Jenkins, the recommended approach is to use Vale's GoDownloader script: # Vale will be installed to ` /bin/vale ` . $ curl -sfL https://install.goreleaser.com/github.com/ValeLint/vale.sh | sh -s vX.Y.Z where vX.Y.Z is your version of choice from the releases page . Local use by a single writer \u00b6 Vale can also be used locally by a single writer through their command line or a third-party integration. Using Vale with a text editor (or another third-party application) \u00b6 Vale has a commercial desktop application, Vale Server , that integrates with many third-party applications (including Atom, Sublime Text, VS Code, and Google Docs) and allows writers to easily create and switch between multiple local Vale configurations. It also offers seamless integration with LanguageTool , providing access to over 2,000 English grammar rules. Using Vale from the command line \u00b6 Vale can be installed for local usage by downloading an executable from the releases page or by pulling the latest Docker container .","title":"Getting Started"},{"location":"#about","text":"Heads up! This documentation is for v1 of Vale. Check out the v2 docs at https://errata-ai.gitbook.io/vale/ ! Vale is a cross-platform (macOS, Windows, and Linux),command-line linter for prose built with speed and extensibility in mind. Unlike most writing-related software, Vale's primary purpose isn't to provide its own advice; it's designed to enforce an existing style guide through its YAML-based extension system . No matter if you're working with a small in-house standard or a large editorial style guide, Vale will help you maintain consistent and error-free writing.","title":"About"},{"location":"#installation","text":"Vale offers multiple options for installation, each of which best suits a particular use case.","title":"Installation"},{"location":"#remote-collaborative-use","text":"One of Vale's strengths is its ability to help a company, project, or organization maintain consistency (capitalization styles, word choice, brand terminology, etc.) across multiple writers. The benefits of the following installation methods are that every writer has access to the same Vale configuration without having to install and configure the tools themselves.","title":"Remote, collaborative use"},{"location":"#using-vale-with-github","text":"If you want to lint the contents of a GitHub repository, the recommended approach is to use Vale's official GitHub Action .","title":"Using Vale with GitHub"},{"location":"#using-vale-with-a-continuous-integration-ci-service","text":"If you want to use Vale with a CI service such as Travis CI, CircleCI, or Jenkins, the recommended approach is to use Vale's GoDownloader script: # Vale will be installed to ` /bin/vale ` . $ curl -sfL https://install.goreleaser.com/github.com/ValeLint/vale.sh | sh -s vX.Y.Z where vX.Y.Z is your version of choice from the releases page .","title":"Using Vale with a continuous integration (CI) service"},{"location":"#local-use-by-a-single-writer","text":"Vale can also be used locally by a single writer through their command line or a third-party integration.","title":"Local use by a single writer"},{"location":"#using-vale-with-a-text-editor-or-another-third-party-application","text":"Vale has a commercial desktop application, Vale Server , that integrates with many third-party applications (including Atom, Sublime Text, VS Code, and Google Docs) and allows writers to easily create and switch between multiple local Vale configurations. It also offers seamless integration with LanguageTool , providing access to over 2,000 English grammar rules.","title":"Using Vale with a text editor (or another third-party application)"},{"location":"#using-vale-from-the-command-line","text":"Vale can be installed for local usage by downloading an executable from the releases page or by pulling the latest Docker container .","title":"Using Vale from the command line"},{"location":"config/","text":"Vale has three configuration components: A .vale.ini (required): This is where you'll control the majority of Vale's behavior, including what files to lint and how to lint them. See the next section for more information. A StylesPath directory (optional): This is where you'll store all of Vale's optional external resources. Custom styles (optional): Custom styles are a means of teaching Vale new guidelines to lint against. .vale.ini \u00b6 # Example Vale config file (`.vale.ini` or `_vale.ini`) # Core settings StylesPath = ci/vale/styles # The minimum alert level to display (suggestion, warning, or error). # # CI builds will only fail on error-level alerts. MinAlertLevel = warning # The \"formats\" section allows you to associate an \"unknown\" format # with one of Vale's supported formats. [formats] mdx = md # Global settings (applied to every syntax) [*] # List of styles to load BasedOnStyles = write-good, Joblint # Style.Rule = {YES, NO} to enable or disable a specific rule vale.Editorializing = YES # You can also change the level associated with a rule vale.Hedging = error # Syntax-specific settings # These overwrite any conflicting global settings [*.{md,txt}] vale.Editorializing = NO Vale expects its configuration to be in a file named .vale.ini or _vale.ini . It'll start looking for this file in the same directory as the file that's being linted. If it can't find one, it'll search up to 6 levels up the directory tree. After 6 levels, it'll look for a global configuration file in the OS equivalent of $HOME (see below). OS Search Locations Windows $HOME , %UserProfile% , or %HomeDrive%%HomePath% macOS $HOME Linux $HOME If more than one configuration file is present, the closest one takes precedence. Available Options \u00b6 StylesPath (core): # Here's an example of a relative path: # # .vale.ini # ci/ # \u251c\u2500\u2500 vale/ # \u2502 \u251c\u2500\u2500 styles/ StylesPath = ci/vale/styles StylesPath specifies where Vale should look for its external resources (e.g., styles and ignore files). The path value may be absolute or relative to the location of the parent .vale.ini file. MinAlertLevel (core): MinAlertLevel = suggestion MinAlertLevel specifies the minimum alert severity that Vale will report. The options are \"suggestion,\" \"warning,\" or \"error\" (defaults to \"suggestion\"). IgnoredScopes (core): # By default, `code` and `tt` are ignored. IgnoredScopes = code, tt IgnoredScopes specifies inline-level HTML tags to ignore. In other words, these tags may occur in an active scope (see SkippedScopes ) but their content still won't raise any alerts. SkippedScopes (core): # By default, `script`, `style`, `pre`, and `figure` are ignored. SkippedScopes = script, style, pre, figure SkippedScopes specifies block-level HTML tags to ignore. Any content in these scopes will be ignored. WordTemplate (core): WordTemplate = `\\b(?:%s)\\b` WordTemplate specifies what Vale will consider to be an individual word. BasedOnStyles (syntax-specific): BasedOnStyles = Joblint, write-good BasedOnStyles specifies styles that should have all of their rules enabled. BlockIgnores (syntax-specific): BlockIgnores = (?s) *({< file [^>]* >}.*?{</ ?file >}) BlockIgnores allow you to exclude certain block-level sections of text that don't have an associated HTML tag that could be used with SkippedScopes . See Non-Standard Markup for more information. TokenIgnores (syntax-specific): TokenIgnores = (\\$+[^\\n$]+\\$+) TokenIgnores allow you to exclude certain inline-level sections of text that don't have an associated HTML tag that could be used with IgnoredScopes . See Non-Standard Markup for more information. Transform (syntax-specific): Transform = docbook-xsl-snapshot/html/docbook.xsl Transform specifies a version 1.0 XSL Transformation (XSLT) for converting to HTML. See Formats#XML for more information. Ignoring Parts of Your Documents \u00b6 NOTE Vale currently does not support comment-based configuration in AsciiDoc documents. Ignore parts of your HTML and Markdown documents using HTML-style comments: <!-- vale off --> This is some text more text here... <!-- vale on --> <!-- vale Style.Rule = NO --> This is some text <!-- vale Style.Rule = YES --> Ignore parts of your reStructuredText documents: .. vale off This is some text .. vale on Vale also ignores specific tags for each supported markup language .","title":"Configuration"},{"location":"config/#valeini","text":"# Example Vale config file (`.vale.ini` or `_vale.ini`) # Core settings StylesPath = ci/vale/styles # The minimum alert level to display (suggestion, warning, or error). # # CI builds will only fail on error-level alerts. MinAlertLevel = warning # The \"formats\" section allows you to associate an \"unknown\" format # with one of Vale's supported formats. [formats] mdx = md # Global settings (applied to every syntax) [*] # List of styles to load BasedOnStyles = write-good, Joblint # Style.Rule = {YES, NO} to enable or disable a specific rule vale.Editorializing = YES # You can also change the level associated with a rule vale.Hedging = error # Syntax-specific settings # These overwrite any conflicting global settings [*.{md,txt}] vale.Editorializing = NO Vale expects its configuration to be in a file named .vale.ini or _vale.ini . It'll start looking for this file in the same directory as the file that's being linted. If it can't find one, it'll search up to 6 levels up the directory tree. After 6 levels, it'll look for a global configuration file in the OS equivalent of $HOME (see below). OS Search Locations Windows $HOME , %UserProfile% , or %HomeDrive%%HomePath% macOS $HOME Linux $HOME If more than one configuration file is present, the closest one takes precedence.","title":".vale.ini"},{"location":"config/#available-options","text":"StylesPath (core): # Here's an example of a relative path: # # .vale.ini # ci/ # \u251c\u2500\u2500 vale/ # \u2502 \u251c\u2500\u2500 styles/ StylesPath = ci/vale/styles StylesPath specifies where Vale should look for its external resources (e.g., styles and ignore files). The path value may be absolute or relative to the location of the parent .vale.ini file. MinAlertLevel (core): MinAlertLevel = suggestion MinAlertLevel specifies the minimum alert severity that Vale will report. The options are \"suggestion,\" \"warning,\" or \"error\" (defaults to \"suggestion\"). IgnoredScopes (core): # By default, `code` and `tt` are ignored. IgnoredScopes = code, tt IgnoredScopes specifies inline-level HTML tags to ignore. In other words, these tags may occur in an active scope (see SkippedScopes ) but their content still won't raise any alerts. SkippedScopes (core): # By default, `script`, `style`, `pre`, and `figure` are ignored. SkippedScopes = script, style, pre, figure SkippedScopes specifies block-level HTML tags to ignore. Any content in these scopes will be ignored. WordTemplate (core): WordTemplate = `\\b(?:%s)\\b` WordTemplate specifies what Vale will consider to be an individual word. BasedOnStyles (syntax-specific): BasedOnStyles = Joblint, write-good BasedOnStyles specifies styles that should have all of their rules enabled. BlockIgnores (syntax-specific): BlockIgnores = (?s) *({< file [^>]* >}.*?{</ ?file >}) BlockIgnores allow you to exclude certain block-level sections of text that don't have an associated HTML tag that could be used with SkippedScopes . See Non-Standard Markup for more information. TokenIgnores (syntax-specific): TokenIgnores = (\\$+[^\\n$]+\\$+) TokenIgnores allow you to exclude certain inline-level sections of text that don't have an associated HTML tag that could be used with IgnoredScopes . See Non-Standard Markup for more information. Transform (syntax-specific): Transform = docbook-xsl-snapshot/html/docbook.xsl Transform specifies a version 1.0 XSL Transformation (XSLT) for converting to HTML. See Formats#XML for more information.","title":"Available Options"},{"location":"config/#ignoring-parts-of-your-documents","text":"NOTE Vale currently does not support comment-based configuration in AsciiDoc documents. Ignore parts of your HTML and Markdown documents using HTML-style comments: <!-- vale off --> This is some text more text here... <!-- vale on --> <!-- vale Style.Rule = NO --> This is some text <!-- vale Style.Rule = YES --> Ignore parts of your reStructuredText documents: .. vale off This is some text .. vale on Vale also ignores specific tags for each supported markup language .","title":"Ignoring Parts of Your Documents"},{"location":"examples/","text":"Projects \u00b6 Vale's own documentation : Vale + MkDocs (Markdown)+ Travis CI. Write the Docs : Vale + Sphinx (reStructuredText) + tox + Travis CI. Linode : Vale + Hugo (Markdown) + Travis CI. CockroachDB : Vale + Jekyll (Markdown) + TeamCity. GOV.UK : Vale + Middleman (Markdown) + Jenkins. Articles \u00b6 An Introduction to Vale (errata.ai) Linters for the English Language (DZone) Vale for Spelling, Grammar, Style and Readability Linting (DZone) Testing your Documentation (Write the Docs) Other \u00b6 WTD Episode 16 (podcast) FOSDEM 19 (presentation)","title":"Examples"},{"location":"examples/#projects","text":"Vale's own documentation : Vale + MkDocs (Markdown)+ Travis CI. Write the Docs : Vale + Sphinx (reStructuredText) + tox + Travis CI. Linode : Vale + Hugo (Markdown) + Travis CI. CockroachDB : Vale + Jekyll (Markdown) + TeamCity. GOV.UK : Vale + Middleman (Markdown) + Jenkins.","title":"Projects"},{"location":"examples/#articles","text":"An Introduction to Vale (errata.ai) Linters for the English Language (DZone) Vale for Spelling, Grammar, Style and Readability Linting (DZone) Testing your Documentation (Write the Docs)","title":"Articles"},{"location":"examples/#other","text":"WTD Episode 16 (podcast) FOSDEM 19 (presentation)","title":"Other"},{"location":"formats/","text":"Overview \u00b6 Vale is \"syntax aware,\" which means that it's capable of both applying rules to and ignoring certain sections of text. This functionality is implemented through a scoping system. A scope is specified through a selector such as paragraph.rst , which indicates that the rule applies to all paragraphs in reStructuredText files. Here are a few examples: comment matches all source code comments; comment.line matches all source code line comments; heading.md matches all Markdown headings; and text.html matches all HTML scopes. The type of file you're working with determines what scopes are available. The supported types are markup , code , and text . Available Scopes \u00b6 markup \u00b6 Scope Description heading Matches all <h{1,...}> tags. You can specify an exact level by appending a tags\u2014for example, heading.h1 matches all h1 tags. table.header Matches all <th> tags. table.cell Matches all <td> tags. list Matches all <li> tags. paragraph Matches all paragraphs (segments of text separated by two newlines). sentence Matches all sentences. link Matches all <a> tags. alt Matches all alt attributes. blockquote Matches all <blockquote> tags. summary Matches all body text (excluding list items, headings, and table cells). code Matches all <code> tags. strong Matches all <strong> and <b> tags. emphasis Matches all <em> and <i> tags code \u00b6 There are two code scopes: comment.line and comment.block . text \u00b6 Any format not listed below is considered to be text and has no special scoping rules applied. Formats \u00b6 Markdown [ markup ] \u00b6 Vale has built-in support for GitHub-Flavored Markdown. By default, it ignores indented blocks, fenced blocks, and code spans. HTML [ markup ] \u00b6 Vale has built-in support for HTML. By default, it ignores script , style , pre , code , and tt tags. reStructuredText [ markup ] \u00b6 Vale supports reStructuredText through the external program rst2html . You can get rst2html by installing either Sphinx or docutils . By default, literal blocks, inline literals, and code-block s are ignored. AsciiDoc [ markup ] \u00b6 Vale supports AsciiDoc through the external program Asciidoctor . By default, listing blocks and inline literals are ignored. DITA [ markup ] \u00b6 NOTE You'll need to manually add the dita-ot-X.X.X/bin directory to your $PATH . Vale supports DITA through the DITA Open Toolkit . By default, script , style , pre , code , and tt tags are ignored. XML [ markup ] \u00b6 Vale supports XML through the external program xsltproc . In order for Vale to understand your XML, you need to provide a version 1.0 XSL Transformation (XSLT) for converting to HTML: [*.xml] Transform = docbook-xsl-snapshot/html/docbook.xsl Source Code [ code ] \u00b6 Language Extensions Tokens (scope) C .c , .h // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) C# .cs , .csx // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) C++ .cpp , .cc , .cxx , .hpp // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) CSS .css /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) Go .go // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) Haskell .hs -- ( text.comment.line.ext ), {- ( text.comment.block.ext ) Java .java , .bsh // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) JavaScript .js // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) LESS .less // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) Lua .lua -- ( text.comment.line.ext ), --[[ ( text.comment.block.ext ) Perl .pl , .pm , .pod # ( text.comment.line.ext ) PHP .php // ( text.comment.line.ext ), # ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) Python .py , .py3 , .pyw , .pyi , .rpy # ( text.comment.line.ext ), \"\"\" ( text.comment.block.ext ) R .r , .R # ( text.comment.line.ext ) Ruby .rb # ( text.comment.line.ext ), ^=begin ( text.comment.block.ext ) Sass .sass // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) Scala .scala , .sbt // ( text.comment.line.ext ), Swift .swift // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) Non-Standard Markup \u00b6 When working with non-HTML markup, you'll probably find that there are certain non-standard sections of text you'd like to ignore. Vale supports doing this at both the block and inline levels. To ignore entire blocks of text\u2014for example, Hugo's shortcodes \u2014you'll want to define BlockIgnores . For example, consider the following shortcode-like file snippet: {< file \"hello.go\" go >} package main import \"fmt\" func main() { fmt.Printf(\"hello, world\\n\") } {</ file >} To ignore all instances of file , we'd use a pattern along the lines of the following: BlockIgnores = (?s) *({< file [^>]* >}.*?{</ ?file >}) The basic idea is to capture the entire snippet in the first grouping. See regex101 for a more thorough explanation. You can also define more than one by using a list (the \\ allows for line breaks): BlockIgnores = (?s) *({< output >}.*?{< ?/ ?output >}), \\ (?s) *({< highlight .* >}.*?{< ?/ ?highlight >}) To ignore an inline section of text, you'll want to define TokenIgnores . For example, let's say we want to ignore math equations of the form $...$ : $\\begin{bmatrix} k & k & k \\end{bmatrix}^T$ Similar to BlockIgnores , we just need to define a pattern: TokenIgnores = (\\$+[^\\n$]+\\$+) See Configuration for more details.","title":"Markup"},{"location":"formats/#overview","text":"Vale is \"syntax aware,\" which means that it's capable of both applying rules to and ignoring certain sections of text. This functionality is implemented through a scoping system. A scope is specified through a selector such as paragraph.rst , which indicates that the rule applies to all paragraphs in reStructuredText files. Here are a few examples: comment matches all source code comments; comment.line matches all source code line comments; heading.md matches all Markdown headings; and text.html matches all HTML scopes. The type of file you're working with determines what scopes are available. The supported types are markup , code , and text .","title":"Overview"},{"location":"formats/#available-scopes","text":"","title":"Available Scopes"},{"location":"formats/#markup","text":"Scope Description heading Matches all <h{1,...}> tags. You can specify an exact level by appending a tags\u2014for example, heading.h1 matches all h1 tags. table.header Matches all <th> tags. table.cell Matches all <td> tags. list Matches all <li> tags. paragraph Matches all paragraphs (segments of text separated by two newlines). sentence Matches all sentences. link Matches all <a> tags. alt Matches all alt attributes. blockquote Matches all <blockquote> tags. summary Matches all body text (excluding list items, headings, and table cells). code Matches all <code> tags. strong Matches all <strong> and <b> tags. emphasis Matches all <em> and <i> tags","title":"markup"},{"location":"formats/#code","text":"There are two code scopes: comment.line and comment.block .","title":"code"},{"location":"formats/#text","text":"Any format not listed below is considered to be text and has no special scoping rules applied.","title":"text"},{"location":"formats/#formats","text":"","title":"Formats"},{"location":"formats/#markdown-markup","text":"Vale has built-in support for GitHub-Flavored Markdown. By default, it ignores indented blocks, fenced blocks, and code spans.","title":"Markdown [markup]"},{"location":"formats/#html-markup","text":"Vale has built-in support for HTML. By default, it ignores script , style , pre , code , and tt tags.","title":"HTML [markup]"},{"location":"formats/#restructuredtext-markup","text":"Vale supports reStructuredText through the external program rst2html . You can get rst2html by installing either Sphinx or docutils . By default, literal blocks, inline literals, and code-block s are ignored.","title":"reStructuredText [markup]"},{"location":"formats/#asciidoc-markup","text":"Vale supports AsciiDoc through the external program Asciidoctor . By default, listing blocks and inline literals are ignored.","title":"AsciiDoc [markup]"},{"location":"formats/#dita-markup","text":"NOTE You'll need to manually add the dita-ot-X.X.X/bin directory to your $PATH . Vale supports DITA through the DITA Open Toolkit . By default, script , style , pre , code , and tt tags are ignored.","title":"DITA [markup]"},{"location":"formats/#xml-markup","text":"Vale supports XML through the external program xsltproc . In order for Vale to understand your XML, you need to provide a version 1.0 XSL Transformation (XSLT) for converting to HTML: [*.xml] Transform = docbook-xsl-snapshot/html/docbook.xsl","title":"XML [markup]"},{"location":"formats/#source-code-code","text":"Language Extensions Tokens (scope) C .c , .h // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) C# .cs , .csx // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) C++ .cpp , .cc , .cxx , .hpp // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) CSS .css /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) Go .go // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) Haskell .hs -- ( text.comment.line.ext ), {- ( text.comment.block.ext ) Java .java , .bsh // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) JavaScript .js // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) LESS .less // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) Lua .lua -- ( text.comment.line.ext ), --[[ ( text.comment.block.ext ) Perl .pl , .pm , .pod # ( text.comment.line.ext ) PHP .php // ( text.comment.line.ext ), # ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) Python .py , .py3 , .pyw , .pyi , .rpy # ( text.comment.line.ext ), \"\"\" ( text.comment.block.ext ) R .r , .R # ( text.comment.line.ext ) Ruby .rb # ( text.comment.line.ext ), ^=begin ( text.comment.block.ext ) Sass .sass // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext ) Scala .scala , .sbt // ( text.comment.line.ext ), Swift .swift // ( text.comment.line.ext ), /*...*/ ( text.comment.line.ext ), /* ( text.comment.block.ext )","title":"Source Code [code]"},{"location":"formats/#non-standard-markup","text":"When working with non-HTML markup, you'll probably find that there are certain non-standard sections of text you'd like to ignore. Vale supports doing this at both the block and inline levels. To ignore entire blocks of text\u2014for example, Hugo's shortcodes \u2014you'll want to define BlockIgnores . For example, consider the following shortcode-like file snippet: {< file \"hello.go\" go >} package main import \"fmt\" func main() { fmt.Printf(\"hello, world\\n\") } {</ file >} To ignore all instances of file , we'd use a pattern along the lines of the following: BlockIgnores = (?s) *({< file [^>]* >}.*?{</ ?file >}) The basic idea is to capture the entire snippet in the first grouping. See regex101 for a more thorough explanation. You can also define more than one by using a list (the \\ allows for line breaks): BlockIgnores = (?s) *({< output >}.*?{< ?/ ?output >}), \\ (?s) *({< highlight .* >}.*?{< ?/ ?highlight >}) To ignore an inline section of text, you'll want to define TokenIgnores . For example, let's say we want to ignore math equations of the form $...$ : $\\begin{bmatrix} k & k & k \\end{bmatrix}^T$ Similar to BlockIgnores , we just need to define a pattern: TokenIgnores = (\\$+[^\\n$]+\\$+) See Configuration for more details.","title":"Non-Standard Markup"},{"location":"plugins/","text":"Overview \u00b6 NOTE Plugins are currently only supported on Linux and macOS. Vale's built-in extension points are designed to cover the majority of linting needs without requiring any programming experience. In some cases, though, regex-based rules simply aren't powerful enough to adequately express a particular rule or guideline. This is where plugins come into play. A \"plugin\" is a Go package that Vale loads at run time, allowing for arbitrary extensions to its built-in functionality. Here's a basic example: // An example plugin showing how to arbitrarily extend Vale via Golang. // // See https://errata-ai.github.io/vale/plugins/ for more information. package main import ( \"strings\" \"github.com/errata-ai/vale/core\" ) // Example extends Vale by implementing a custom rule. // // The name of this function (i.e., \"Example\") *must* match the name of its // file (i.e., \"Example.go\"). func Example () core . Plugin { return core . Plugin { // Scope determines where this rule applies. // // See https://errata-ai.github.io/vale/formats/. Scope : \"heading\" , // Level specifies the importance of this rule. // // See https://errata-ai.github.io/vale/styles/#extension-points. Level : \"warning\" , // Rule is the entry point to your custom rule. // // You need to return a slice of Alerts specifying the rule's location // (`span`), and message (`Message`). // // `text` will be the content of the scope specified above. Rule : func ( text string , file * core . File ) [] core . Alert { alerts := [] core . Alert {} if strings . ToLower ( text ) == text { alerts = append ( alerts , core . Alert { // The location of our alert relative to `text`. Span : [] int { 0 , len ( text )}, Message : \"Capitalize your headings!\" }) } return alerts }, } } With plugins, you have complete access to Go and its standard library , as well as the ability to call scripts from other programming languages using the exec package. Creating a Plugin \u00b6 NOTE Plugins require Go >= v1.8.0. To create your own plugin, simply export a function returning a Plugin as shown in the example above. The Rule implementation can be as complex as you need and use any aspect of the Go programming language. After you've created your plugin, place it in StylesPath/plugins and compile it using -buildmode=plugin : $ go build -buildmode = plugin MyPlugin.go This will produce a shared object ( MyPlugin.so ) containing your plugin's logic. Typical Workflow \u00b6 You'll want to commit your plugin's source file ( .go ) into version control, but not its shared object ( .so ). This means that if you're using a CI service, you'll need to build your plugin(s) prior to running Vale. One way to do this is by creating a Makefile : plugins: cd styles/plugins/ && \\ go build -buildmode=plugin MyPlugin.go && \\ go build -buildmode=plugin MyOtherPlugin.go You can then run make plugins as a CI step.","title":"Plugins"},{"location":"plugins/#overview","text":"NOTE Plugins are currently only supported on Linux and macOS. Vale's built-in extension points are designed to cover the majority of linting needs without requiring any programming experience. In some cases, though, regex-based rules simply aren't powerful enough to adequately express a particular rule or guideline. This is where plugins come into play. A \"plugin\" is a Go package that Vale loads at run time, allowing for arbitrary extensions to its built-in functionality. Here's a basic example: // An example plugin showing how to arbitrarily extend Vale via Golang. // // See https://errata-ai.github.io/vale/plugins/ for more information. package main import ( \"strings\" \"github.com/errata-ai/vale/core\" ) // Example extends Vale by implementing a custom rule. // // The name of this function (i.e., \"Example\") *must* match the name of its // file (i.e., \"Example.go\"). func Example () core . Plugin { return core . Plugin { // Scope determines where this rule applies. // // See https://errata-ai.github.io/vale/formats/. Scope : \"heading\" , // Level specifies the importance of this rule. // // See https://errata-ai.github.io/vale/styles/#extension-points. Level : \"warning\" , // Rule is the entry point to your custom rule. // // You need to return a slice of Alerts specifying the rule's location // (`span`), and message (`Message`). // // `text` will be the content of the scope specified above. Rule : func ( text string , file * core . File ) [] core . Alert { alerts := [] core . Alert {} if strings . ToLower ( text ) == text { alerts = append ( alerts , core . Alert { // The location of our alert relative to `text`. Span : [] int { 0 , len ( text )}, Message : \"Capitalize your headings!\" }) } return alerts }, } } With plugins, you have complete access to Go and its standard library , as well as the ability to call scripts from other programming languages using the exec package.","title":"Overview"},{"location":"plugins/#creating-a-plugin","text":"NOTE Plugins require Go >= v1.8.0. To create your own plugin, simply export a function returning a Plugin as shown in the example above. The Rule implementation can be as complex as you need and use any aspect of the Go programming language. After you've created your plugin, place it in StylesPath/plugins and compile it using -buildmode=plugin : $ go build -buildmode = plugin MyPlugin.go This will produce a shared object ( MyPlugin.so ) containing your plugin's logic.","title":"Creating a Plugin"},{"location":"plugins/#typical-workflow","text":"You'll want to commit your plugin's source file ( .go ) into version control, but not its shared object ( .so ). This means that if you're using a CI service, you'll need to build your plugin(s) prior to running Vale. One way to do this is by creating a Makefile : plugins: cd styles/plugins/ && \\ go build -buildmode=plugin MyPlugin.go && \\ go build -buildmode=plugin MyOtherPlugin.go You can then run make plugins as a CI step.","title":"Typical Workflow"},{"location":"styles/","text":"Introduction \u00b6 Vale has a powerful extension system that doesn't require knowledge of any programming language. Instead, it exposes its functionality through simple YAML files. NOTE Vale expects its external rules to have an extension of .yml , not .yaml , etc. The core component of Vale's extension system are collections of writing guidelines called styles . These guidelines are expressed through rules , which are YAML files enforcing a particular writing construct\u2014e.g., ensuring a certain readability level, sentence length, or heading style. Styles are organized in a hierarchical folder structure at a user-specified location (see Configuration for more details). For example, styles/ \u251c\u2500\u2500 base/ \u2502 \u251c\u2500\u2500 ComplexWords.yml \u2502 \u251c\u2500\u2500 SentenceLength.yml \u2502 ... \u251c\u2500\u2500 blog/ \u2502 \u251c\u2500\u2500 TechTerms.yml \u2502 ... \u2514\u2500\u2500 docs/ \u251c\u2500\u2500 Branding.yml ... where base , blog , and docs are your styles. Extension Points \u00b6 The building blocks behind Vale's styles are rules, which utilize extension points to perform specific tasks. The basic structure of a rule consists of a small header (shown below) followed by extension-specific arguments. # All rules should define the following header keys: # # `extends` indicates the extension point being used (see below for information # on the possible values). extends : existence # `message` is shown to the user when the rule is broken. # # Many extension points accept format specifiers (%s), which are replaced by # extracted values. See the exention-specific sections below for more details. message : \"Consider removing '%s'\" # `level` assigns the rule's severity. # # The accepted values are suggestion, warning, and error. level : warning # `scope` specifies where this rule should apply -- e.g., headings, sentences, etc. # # See the Markup section for more information on scoping. scope : heading # `code` determines whether or not the content of code spans -- e.g., `foo` for # Markdown -- is ignored. code : false # `link` gives the source for this rule. link : 'https://errata.ai/' Creating a Style \u00b6 checks offer a high-level way to extend Vale. They perform operations such as checking for consistency, counting occurrences, and suggesting changes. NOTE Vale uses Go's regexp package to evaluate all patterns in rule definitions. This means that lookarounds and backreferences aren't supported. existence \u00b6 Example Definition: extends : existence message : Consider removing '%s' level : warning code : false ignorecase : true tokens : - appears to be - arguably Key Summary: NAME TYPE DESCRIPTION append bool Adds raw to the end of tokens , assuming both are defined. ignorecase bool Makes all matches case-insensitive. nonword bool Removes the default word boundaries ( \\b ). raw array A list of tokens to be concatenated into a pattern. tokens array A list of tokens to be transformed into a non-capturing group. The most general extension point is existence . As its name implies, it looks for the \"existence\" of particular tokens. These tokens can be anything from simple phrases (as in the above example) to complex regular expressions\u2014e.g., the number of spaces between sentences and the position of punctuation after quotes . You may define the tokens as elements of lists named either tokens (shown above) or raw . The former converts its elements into a word-bounded, non-capturing group. For instance, tokens : - appears to be - arguably becomes \\b(?:appears to be|arguably)\\b . raw , on the other hand, simply concatenates its elements\u2014so, something like raw : - '(?:foo)\\sbar' - '(baz)' becomes (?:foo)\\sbar(baz) . substitution \u00b6 Example Definition: extends : substitution message : Consider using '%s' instead of '%s' level : warning ignorecase : false # swap maps tokens in form of bad: good swap : abundance : plenty accelerate : speed up Key Summary: NAME TYPE DESCRIPTION ignorecase bool Makes all matches case-insensitive. nonword bool Removes the default word boundaries ( \\b ). swap map A sequence of observed: expected pairs. pos string A regular expression matching tokens to parts of speech. substitution associates a string with a preferred form. If we want to suggest the use of \"plenty\" instead of \"abundance,\" for example, we'd write: swap : abundance : plenty The keys may be regular expressions, but they can't include nested capture groups: swap : '(?:give|gave) rise to' : lead to # this is okay '(give|gave) rise to' : lead to # this is bad! Like existence , substitution accepts the keys ignorecase and nonword . substitution can have one or two %s format specifiers in its message. This allows us to do either of the following: message : \"Consider using '%s' instead of '%s'\" # or message : \"Consider using '%s'\" occurrence \u00b6 Example Definition: extends : occurrence message : \"More than 3 commas!\" level : error # Here, we're counting the number of times a comma appears in a sentence. # If it occurs more than 3 times, we'll flag it. scope : sentence ignorecase : false max : 3 token : ',' Key Summary: NAME TYPE DESCRIPTION max int The maximum amount of times token may appear in a given scope. min int The minimum amount of times token has to appear in a given scope. token string The token of interest. occurrence enforces the maximum or minimum number of times a particular token can appear in a given scope. In the example above, we're limiting the number of words per sentence. This is the only extension point that doesn't accept a format specifier in its message. repetition \u00b6 Example Definition: extends : repetition message : \"'%s' is repeated!\" level : error alpha : true tokens : - '[^\\s]+' Key Summary: NAME TYPE DESCRIPTION ignorecase bool Makes all matches case-insensitive. alpha bool Limits all matches to alphanumeric tokens. tokens array A list of tokens to be transformed into a non-capturing group. repetition looks for repeated occurrences of its tokens. If ignorecase is set to true , it'll convert all tokens to lower case for comparison purposes. consistency \u00b6 Example Definition: extends : consistency message : \"Inconsistent spelling of '%s'\" level : error scope : text ignorecase : true nonword : false # We only want one of these to appear. either : advisor : adviser centre : center Key Summary: NAME TYPE DESCRIPTION nonword bool Removes the default word boundaries ( \\b ). ignorecase bool Makes all matches case-insensitive. either map A map of option 1: option 2 pairs, of which only one may appear. consistency will ensure that a key and its value (e.g., \"advisor\" and \"adviser\") don't both occur in its scope. conditional \u00b6 Example Definition: extends : conditional message : \"'%s' has no definition\" level : error scope : text ignorecase : false # Ensures that the existence of 'first' implies the existence of 'second'. first : \\b([A-Z]{3,5})\\b second : (?:\\b[A-Z][a-z]+ )+\\(([A-Z]{3,5})\\) # ... with the exception of these: exceptions : - ABC - ADD Key Summary: NAME TYPE DESCRIPTION ignorecase bool Makes all matches case-insensitive. first string The antecedent of the statement. second string The consequent of the statement. exceptions array An array of strings to be ignored. conditional ensures that the existence of first implies the existence of second . For example, consider the following text: According to Wikipedia, the World Health Organization (WHO) is a specialized agency of the United Nations that is concerned with international public health. We can now use WHO because it has been defined, but we can't use DAFB because people may not know what it represents. We can use DAFB when it's presented as code, though. Running vale on the above text with our example rule yields the following: test.md:1:224:vale.UnexpandedAcronyms: 'DAFB' has no definition conditional also takes an optional exceptions list. Any token listed as an exception won't be flagged. capitalization \u00b6 Example Definition: extends : capitalization message : \"'%s' should be in title case\" level : warning scope : heading # $title, $sentence, $lower, $upper, or a pattern. match : $title style : AP # AP or Chicago; only applies when match is set to $title. Key Summary: NAME TYPE DESCRIPTION match string $title, $sentence, $lower, $upper, or a pattern. style string AP or Chicago; only applies when match is set to $title. exceptions array An array of strings to be ignored. capitalization checks that the text in the specified scope matches the case of match . There are a few pre-defined variables that can be passed as matches: $title : \"The Quick Brown Fox Jumps Over the Lazy Dog.\" $sentence : \"The quick brown fox jumps over the lazy dog.\" $lower : \"the quick brown fox jumps over the lazy dog.\" $upper : \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\" Additionally, when using match: $title , you can specify a style of either AP or Chicago. readability \u00b6 Example Definition: extends : readability message : \"Grade level (%s) too high!\" level : warning grade : 8 metrics : - Flesch-Kincaid - Gunning Fog Key Summary: NAME TYPE DESCRIPTION metrics array One or more of Gunning Fog, Coleman-Liau, Flesch-Kincaid, SMOG, and Automated Readability. grade float The highest acceptable score. readability calculates a readability score according the specified metrics. The supported tests are Gunning-Fog, Coleman-Liau, Flesch-Kincaid, SMOG, and Automated Readability. If more than one is listed (as seen above), the scores will be averaged. This is also the only extension point that doesn't accept a scope, as readability is always calculated using the entire document. grade is the highest acceptable score. Using the example above, a warning will be issued if grade exceeds 8. spelling \u00b6 Example Definition: extends : spelling message : \"Did you really mean '%s'?\" level : error ignore : ci/vocab.txt Key Summary: NAME TYPE DESCRIPTION aff string The fully-qualified path to a Hunspell-compatible .aff file. custom bool Turn off the default filters for acronyms, abbreviations, and numbers. dic string The fully-qualified path to a Hunspell-compatible .dic file. filters array An array of patterns to ignore during spell checking. ignore string A relative path (from StylesPath ) to a personal vocabulary file consisting of one word per line to ignore. spelling implements spell checking based on Hunspell-compatible dictionaries. By default, Vale includes en_US-web \u2014an up-to-date, actively maintained dictionary. However, you may also specify your own via the dic and aff keys (the fully-qualified paths are required; e.g., /usr/share/hunspell/en_US.dic ). spelling also accepts an ignore file, which consists of one word per line to be ignored during spell checking. You may further customize the spell-checking experience by defining filters : extends : spelling message : \"Did you really mean '%s'?\" level : error # This disables the built-in filters. If you omit this key or set it to false, # custom filters (see below) are added on top of the built-in ones. # # By default, Vale includes filters for acronyms, abbreviations, and numbers. custom : true # A \"filter\" is a regular expression specifying words to ignore during spell # checking. filters : # Ignore all words starting with 'py' -- e.g., 'PyYAML'. - '[pP]y.*\\b' # Vale will search for these files under $StylesPath -- so, vocab.txt is assumed # to be $StylesPath/vocab.txt. ignore : - vocab.txt Default Style \u00b6 Vale comes with a single built-in style named Vale that implements two rules, as described in the table below. Rule Scope Level Description Vale.Spelling text error Spell checks text while respecting the words listed in a $StylesPath/vocab.txt ignore file. Vale.Repetition text error Looks for instances of repeated words such as \"the the\" or \"this this.\"","title":"Styles"},{"location":"styles/#introduction","text":"Vale has a powerful extension system that doesn't require knowledge of any programming language. Instead, it exposes its functionality through simple YAML files. NOTE Vale expects its external rules to have an extension of .yml , not .yaml , etc. The core component of Vale's extension system are collections of writing guidelines called styles . These guidelines are expressed through rules , which are YAML files enforcing a particular writing construct\u2014e.g., ensuring a certain readability level, sentence length, or heading style. Styles are organized in a hierarchical folder structure at a user-specified location (see Configuration for more details). For example, styles/ \u251c\u2500\u2500 base/ \u2502 \u251c\u2500\u2500 ComplexWords.yml \u2502 \u251c\u2500\u2500 SentenceLength.yml \u2502 ... \u251c\u2500\u2500 blog/ \u2502 \u251c\u2500\u2500 TechTerms.yml \u2502 ... \u2514\u2500\u2500 docs/ \u251c\u2500\u2500 Branding.yml ... where base , blog , and docs are your styles.","title":"Introduction"},{"location":"styles/#extension-points","text":"The building blocks behind Vale's styles are rules, which utilize extension points to perform specific tasks. The basic structure of a rule consists of a small header (shown below) followed by extension-specific arguments. # All rules should define the following header keys: # # `extends` indicates the extension point being used (see below for information # on the possible values). extends : existence # `message` is shown to the user when the rule is broken. # # Many extension points accept format specifiers (%s), which are replaced by # extracted values. See the exention-specific sections below for more details. message : \"Consider removing '%s'\" # `level` assigns the rule's severity. # # The accepted values are suggestion, warning, and error. level : warning # `scope` specifies where this rule should apply -- e.g., headings, sentences, etc. # # See the Markup section for more information on scoping. scope : heading # `code` determines whether or not the content of code spans -- e.g., `foo` for # Markdown -- is ignored. code : false # `link` gives the source for this rule. link : 'https://errata.ai/'","title":"Extension Points"},{"location":"styles/#creating-a-style","text":"checks offer a high-level way to extend Vale. They perform operations such as checking for consistency, counting occurrences, and suggesting changes. NOTE Vale uses Go's regexp package to evaluate all patterns in rule definitions. This means that lookarounds and backreferences aren't supported.","title":"Creating a Style"},{"location":"styles/#existence","text":"Example Definition: extends : existence message : Consider removing '%s' level : warning code : false ignorecase : true tokens : - appears to be - arguably Key Summary: NAME TYPE DESCRIPTION append bool Adds raw to the end of tokens , assuming both are defined. ignorecase bool Makes all matches case-insensitive. nonword bool Removes the default word boundaries ( \\b ). raw array A list of tokens to be concatenated into a pattern. tokens array A list of tokens to be transformed into a non-capturing group. The most general extension point is existence . As its name implies, it looks for the \"existence\" of particular tokens. These tokens can be anything from simple phrases (as in the above example) to complex regular expressions\u2014e.g., the number of spaces between sentences and the position of punctuation after quotes . You may define the tokens as elements of lists named either tokens (shown above) or raw . The former converts its elements into a word-bounded, non-capturing group. For instance, tokens : - appears to be - arguably becomes \\b(?:appears to be|arguably)\\b . raw , on the other hand, simply concatenates its elements\u2014so, something like raw : - '(?:foo)\\sbar' - '(baz)' becomes (?:foo)\\sbar(baz) .","title":"existence"},{"location":"styles/#substitution","text":"Example Definition: extends : substitution message : Consider using '%s' instead of '%s' level : warning ignorecase : false # swap maps tokens in form of bad: good swap : abundance : plenty accelerate : speed up Key Summary: NAME TYPE DESCRIPTION ignorecase bool Makes all matches case-insensitive. nonword bool Removes the default word boundaries ( \\b ). swap map A sequence of observed: expected pairs. pos string A regular expression matching tokens to parts of speech. substitution associates a string with a preferred form. If we want to suggest the use of \"plenty\" instead of \"abundance,\" for example, we'd write: swap : abundance : plenty The keys may be regular expressions, but they can't include nested capture groups: swap : '(?:give|gave) rise to' : lead to # this is okay '(give|gave) rise to' : lead to # this is bad! Like existence , substitution accepts the keys ignorecase and nonword . substitution can have one or two %s format specifiers in its message. This allows us to do either of the following: message : \"Consider using '%s' instead of '%s'\" # or message : \"Consider using '%s'\"","title":"substitution"},{"location":"styles/#occurrence","text":"Example Definition: extends : occurrence message : \"More than 3 commas!\" level : error # Here, we're counting the number of times a comma appears in a sentence. # If it occurs more than 3 times, we'll flag it. scope : sentence ignorecase : false max : 3 token : ',' Key Summary: NAME TYPE DESCRIPTION max int The maximum amount of times token may appear in a given scope. min int The minimum amount of times token has to appear in a given scope. token string The token of interest. occurrence enforces the maximum or minimum number of times a particular token can appear in a given scope. In the example above, we're limiting the number of words per sentence. This is the only extension point that doesn't accept a format specifier in its message.","title":"occurrence"},{"location":"styles/#repetition","text":"Example Definition: extends : repetition message : \"'%s' is repeated!\" level : error alpha : true tokens : - '[^\\s]+' Key Summary: NAME TYPE DESCRIPTION ignorecase bool Makes all matches case-insensitive. alpha bool Limits all matches to alphanumeric tokens. tokens array A list of tokens to be transformed into a non-capturing group. repetition looks for repeated occurrences of its tokens. If ignorecase is set to true , it'll convert all tokens to lower case for comparison purposes.","title":"repetition"},{"location":"styles/#consistency","text":"Example Definition: extends : consistency message : \"Inconsistent spelling of '%s'\" level : error scope : text ignorecase : true nonword : false # We only want one of these to appear. either : advisor : adviser centre : center Key Summary: NAME TYPE DESCRIPTION nonword bool Removes the default word boundaries ( \\b ). ignorecase bool Makes all matches case-insensitive. either map A map of option 1: option 2 pairs, of which only one may appear. consistency will ensure that a key and its value (e.g., \"advisor\" and \"adviser\") don't both occur in its scope.","title":"consistency"},{"location":"styles/#conditional","text":"Example Definition: extends : conditional message : \"'%s' has no definition\" level : error scope : text ignorecase : false # Ensures that the existence of 'first' implies the existence of 'second'. first : \\b([A-Z]{3,5})\\b second : (?:\\b[A-Z][a-z]+ )+\\(([A-Z]{3,5})\\) # ... with the exception of these: exceptions : - ABC - ADD Key Summary: NAME TYPE DESCRIPTION ignorecase bool Makes all matches case-insensitive. first string The antecedent of the statement. second string The consequent of the statement. exceptions array An array of strings to be ignored. conditional ensures that the existence of first implies the existence of second . For example, consider the following text: According to Wikipedia, the World Health Organization (WHO) is a specialized agency of the United Nations that is concerned with international public health. We can now use WHO because it has been defined, but we can't use DAFB because people may not know what it represents. We can use DAFB when it's presented as code, though. Running vale on the above text with our example rule yields the following: test.md:1:224:vale.UnexpandedAcronyms: 'DAFB' has no definition conditional also takes an optional exceptions list. Any token listed as an exception won't be flagged.","title":"conditional"},{"location":"styles/#capitalization","text":"Example Definition: extends : capitalization message : \"'%s' should be in title case\" level : warning scope : heading # $title, $sentence, $lower, $upper, or a pattern. match : $title style : AP # AP or Chicago; only applies when match is set to $title. Key Summary: NAME TYPE DESCRIPTION match string $title, $sentence, $lower, $upper, or a pattern. style string AP or Chicago; only applies when match is set to $title. exceptions array An array of strings to be ignored. capitalization checks that the text in the specified scope matches the case of match . There are a few pre-defined variables that can be passed as matches: $title : \"The Quick Brown Fox Jumps Over the Lazy Dog.\" $sentence : \"The quick brown fox jumps over the lazy dog.\" $lower : \"the quick brown fox jumps over the lazy dog.\" $upper : \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\" Additionally, when using match: $title , you can specify a style of either AP or Chicago.","title":"capitalization"},{"location":"styles/#readability","text":"Example Definition: extends : readability message : \"Grade level (%s) too high!\" level : warning grade : 8 metrics : - Flesch-Kincaid - Gunning Fog Key Summary: NAME TYPE DESCRIPTION metrics array One or more of Gunning Fog, Coleman-Liau, Flesch-Kincaid, SMOG, and Automated Readability. grade float The highest acceptable score. readability calculates a readability score according the specified metrics. The supported tests are Gunning-Fog, Coleman-Liau, Flesch-Kincaid, SMOG, and Automated Readability. If more than one is listed (as seen above), the scores will be averaged. This is also the only extension point that doesn't accept a scope, as readability is always calculated using the entire document. grade is the highest acceptable score. Using the example above, a warning will be issued if grade exceeds 8.","title":"readability"},{"location":"styles/#spelling","text":"Example Definition: extends : spelling message : \"Did you really mean '%s'?\" level : error ignore : ci/vocab.txt Key Summary: NAME TYPE DESCRIPTION aff string The fully-qualified path to a Hunspell-compatible .aff file. custom bool Turn off the default filters for acronyms, abbreviations, and numbers. dic string The fully-qualified path to a Hunspell-compatible .dic file. filters array An array of patterns to ignore during spell checking. ignore string A relative path (from StylesPath ) to a personal vocabulary file consisting of one word per line to ignore. spelling implements spell checking based on Hunspell-compatible dictionaries. By default, Vale includes en_US-web \u2014an up-to-date, actively maintained dictionary. However, you may also specify your own via the dic and aff keys (the fully-qualified paths are required; e.g., /usr/share/hunspell/en_US.dic ). spelling also accepts an ignore file, which consists of one word per line to be ignored during spell checking. You may further customize the spell-checking experience by defining filters : extends : spelling message : \"Did you really mean '%s'?\" level : error # This disables the built-in filters. If you omit this key or set it to false, # custom filters (see below) are added on top of the built-in ones. # # By default, Vale includes filters for acronyms, abbreviations, and numbers. custom : true # A \"filter\" is a regular expression specifying words to ignore during spell # checking. filters : # Ignore all words starting with 'py' -- e.g., 'PyYAML'. - '[pP]y.*\\b' # Vale will search for these files under $StylesPath -- so, vocab.txt is assumed # to be $StylesPath/vocab.txt. ignore : - vocab.txt","title":"spelling"},{"location":"styles/#default-style","text":"Vale comes with a single built-in style named Vale that implements two rules, as described in the table below. Rule Scope Level Description Vale.Spelling text error Spell checks text while respecting the words listed in a $StylesPath/vocab.txt ignore file. Vale.Repetition text error Looks for instances of repeated words such as \"the the\" or \"this this.\"","title":"Default Style"},{"location":"usage/","text":"Using the CLI \u00b6 At its core, Vale is designed to be used as a command-line tool. The available commands and options are discussed below. dc / dump-config : $ vale dc ... The dump-config command prints Vale's configuration, as read from its .vale.ini file, to stdout . new : $ vale new existence ... The new command generates an example implementation for the given extension point. -h / --help : $ vale -h ... The --help option prints Vale's CLI usage information to stdout . --glob : # Only search `.md` and `.rst` files $ vale --glob = '*.{md,rst}' directory The --glob option specifies the type of files Vale will search. It accepts the standard GNU/Linux syntax . Additionally, any pattern prefixed with an ! will be negated. For example, # Exclude `.txt` files $ vale --glob = '!*.txt' directory This option takes precedence over any patterns defined in a configuration file . --config : $ vale --config = 'some/file/path/.vale.ini' The --config option specifies the location of a configuration file . This will take precedence over the default search process . --output : # \"line\", \"JSON\", or \"CLI\" (the default) $ vale --output = JSON directory The --output option specifies the format that Vale will use to report its alerts. --ext : $ vale --ext = '.md' '# this is a heading' The --ext option allows you to assign a format (e.g., .md ) to text passed via stdin (which will default to .txt ). --no-wrap : $ vale --no-wrap directory The --no-wrap option disables word wrapping when using the CLI output format. By default, CLI output will be wrapped to fit your console. --no-exit : $ vale --no-exit directory The --no-exit option instructs Vale to always return an exit code of 0 , even if errors were found. This is useful if you don't want CI builds to fail on Vale-related errors. --sort : $ vale --sort directory The --sort option instructs Vale to sort its output by file path. For large directories, this can have a noticeable negative impact on performance. --ignore-syntax : $ vale --ignore-syntax directory The --ignore-syntax option will cause Vale to parse all files as plain text. Note, though, that this doesn't change what files Vale will search . This will often boost performance significantly, but only text -scoped rules will work. -v / --version : $ vale -v ... The --version option prints Vale's version. --debug : $ vale --debug test.md ... The --debug option instructs Vale to print debugging information to stdout .","title":"Usage"},{"location":"usage/#using-the-cli","text":"At its core, Vale is designed to be used as a command-line tool. The available commands and options are discussed below. dc / dump-config : $ vale dc ... The dump-config command prints Vale's configuration, as read from its .vale.ini file, to stdout . new : $ vale new existence ... The new command generates an example implementation for the given extension point. -h / --help : $ vale -h ... The --help option prints Vale's CLI usage information to stdout . --glob : # Only search `.md` and `.rst` files $ vale --glob = '*.{md,rst}' directory The --glob option specifies the type of files Vale will search. It accepts the standard GNU/Linux syntax . Additionally, any pattern prefixed with an ! will be negated. For example, # Exclude `.txt` files $ vale --glob = '!*.txt' directory This option takes precedence over any patterns defined in a configuration file . --config : $ vale --config = 'some/file/path/.vale.ini' The --config option specifies the location of a configuration file . This will take precedence over the default search process . --output : # \"line\", \"JSON\", or \"CLI\" (the default) $ vale --output = JSON directory The --output option specifies the format that Vale will use to report its alerts. --ext : $ vale --ext = '.md' '# this is a heading' The --ext option allows you to assign a format (e.g., .md ) to text passed via stdin (which will default to .txt ). --no-wrap : $ vale --no-wrap directory The --no-wrap option disables word wrapping when using the CLI output format. By default, CLI output will be wrapped to fit your console. --no-exit : $ vale --no-exit directory The --no-exit option instructs Vale to always return an exit code of 0 , even if errors were found. This is useful if you don't want CI builds to fail on Vale-related errors. --sort : $ vale --sort directory The --sort option instructs Vale to sort its output by file path. For large directories, this can have a noticeable negative impact on performance. --ignore-syntax : $ vale --ignore-syntax directory The --ignore-syntax option will cause Vale to parse all files as plain text. Note, though, that this doesn't change what files Vale will search . This will often boost performance significantly, but only text -scoped rules will work. -v / --version : $ vale -v ... The --version option prints Vale's version. --debug : $ vale --debug test.md ... The --debug option instructs Vale to print debugging information to stdout .","title":"Using the CLI"},{"location":"api/capitalization/keys/","text":"NAME TYPE DESCRIPTION match string $title, $sentence, $lower, $upper, or a pattern. style string AP or Chicago; only applies when match is set to $title. exceptions array An array of strings to be ignored.","title":"Keys"},{"location":"api/conditional/keys/","text":"NAME TYPE DESCRIPTION ignorecase bool Makes all matches case-insensitive. first string The antecedent of the statement. second string The consequent of the statement. exceptions array An array of strings to be ignored.","title":"Keys"},{"location":"api/consistency/keys/","text":"NAME TYPE DESCRIPTION nonword bool Removes the default word boundaries ( \\b ). ignorecase bool Makes all matches case-insensitive. either map A map of option 1: option 2 pairs, of which only one may appear.","title":"Keys"},{"location":"api/existence/keys/","text":"NAME TYPE DESCRIPTION append bool Adds raw to the end of tokens , assuming both are defined. ignorecase bool Makes all matches case-insensitive. nonword bool Removes the default word boundaries ( \\b ). raw array A list of tokens to be concatenated into a pattern. tokens array A list of tokens to be transformed into a non-capturing group.","title":"Keys"},{"location":"api/occurrence/keys/","text":"NAME TYPE DESCRIPTION max int The maximum amount of times token may appear in a given scope. min int The minimum amount of times token has to appear in a given scope. token string The token of interest.","title":"Keys"},{"location":"api/readability/keys/","text":"NAME TYPE DESCRIPTION metrics array One or more of Gunning Fog, Coleman-Liau, Flesch-Kincaid, SMOG, and Automated Readability. grade float The highest acceptable score.","title":"Keys"},{"location":"api/repetition/keys/","text":"NAME TYPE DESCRIPTION ignorecase bool Makes all matches case-insensitive. alpha bool Limits all matches to alphanumeric tokens. tokens array A list of tokens to be transformed into a non-capturing group.","title":"Keys"},{"location":"api/spelling/keys/","text":"NAME TYPE DESCRIPTION aff string The fully-qualified path to a Hunspell-compatible .aff file. custom bool Turn off the default filters for acronyms, abbreviations, and numbers. dic string The fully-qualified path to a Hunspell-compatible .dic file. filters array An array of patterns to ignore during spell checking. ignore string A relative path (from StylesPath ) to a personal vocabulary file consisting of one word per line to ignore.","title":"Keys"},{"location":"api/substitution/keys/","text":"NAME TYPE DESCRIPTION ignorecase bool Makes all matches case-insensitive. nonword bool Removes the default word boundaries ( \\b ). swap map A sequence of observed: expected pairs. pos string A regular expression matching tokens to parts of speech.","title":"Keys"}]}